### 1.XML 和 HTML

**XML 被设计用来**传输和存储数据。 其焦点是数据的内容。   

HTML 被设计用来显示数据。其焦点是数据的外观

### 2.AJAX 简介

AJAX = Asynchronous JavaScript and XML (异步JavaScript和XML)

AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。

### 3.cookie如何处理？

创建cookie->创建handler携带cookie->使用opener携带handler进行请求

### 4.请谈一下get和post的区别？

**形式上**：get请求参数拼接在url后面   post请求不体现在url中.

**内容上**：get请求有数据量的限制（不同的浏览器对url最大长度都有不同的限制），post的请求是不限制请求体数据量的（有的web服务器会有一个最大请求体的限制，比如阿帕奇限制为20M）

post 在处理用户输入的特殊字符时，效果好于 get

### 5.什么是并行和并发?

**并行**：多个进程在同一时刻同时进行
**并发**：多个进程在同一时间段内交替进行 （操作系统大多采用并发机制），根据一定的算法(常见的就是时间片轮询算法)

### 6.什么是Vue响应式

​	数据发生变化后，会重新对页面渲染，这就是Vue响应式

#### 6.1 想完成这个过程，我们需要做些什么

- 侦测数据的变化
- 收集视图依赖了哪些数据
- 数据变化时，自动“通知”需要更新的视图部分，并进行更新

**「它们对应专业俗语分别是：」**

- 数据劫持 / 数据代理
- 依赖收集
- 发布订阅模式

#### 6.2 如何侦测数据的变化

有两种办法可以侦测到变化：
使用`Object.defineProperty`和ES6的`Proxy`，这就是进行数据劫持或数据代理。

#### 6.3 收集依赖

##### 为什么要收集依赖

> 我们之所以要观察数据，其目的在于当数据的属性发生变化时，可以通知那些曾经使用了该数据的地方。比如例子中，模板中使用了location 数据，当它发生变化时，要向使用了它的地方发送通知。

订阅者 Dep

##### 为什么引入 Dep

收集依赖需要为依赖找一个存储依赖的地方，为此我们创建了Dep,它用来`收集依赖`、`删除依赖`和`向依赖发送`消息等。

#### 6.4 观察者 Watcher

##### 【为什么引入Watcher】

当`属性`发生变化后，我们要通知`用到数据`的地方，而使用这个数据的地方有很多，而且类型还不一样，既有可能是模板，也有可能是用户写的一个watch,这时需要抽象出一个`能集中处理`这些情况的类。然后，我们在依赖收集阶段只收集这个封装好的类的实例进来，通知也只通知它一个，再由它负责通知其他地方

##### **「依赖收集的目的是:」** 

将观察者 Watcher 对象存放到当前闭包中的订阅者 Dep 的 subs 中。形成如下所示的这样一个关系



![img](https://user-gold-cdn.xitu.io/2020/7/12/17343bec8082db69?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 7. 什么是MVVM

**View层**：视图展示。包含UIView以及UIViewController，View层是可以持有ViewModel的。

**ViewModel层**：视图适配器。暴露属性与View元素显示内容或者元素状态一一对应。一般情况下ViewModel暴露的属性建议是readOnly的，至于为什么，我们在实战中会去解释。还有一点，ViewModel层是可以持有Model的。

**Model层**：数据模型与持久化抽象模型。数据模型很好理解，就是从服务器拉回来的JSON数据。而持久化抽象模型暂时放在Model层，是因为MVVM诞生之初就没有对这块进行很细致的描述。按照经验，我们通常把数据库、文件操作封装成Model，并对外提供操作接口。（有些公司把数据存取操作单拎出来一层，称之为**DataAdapter层**，所以在业内会有很多MVVM的变种，但其本质上都是MVVM）。

**Binder**：MVVM的灵魂。可惜在MVVM这几个英文单词中并没有它的一席之地，它的最主要作用是在View和ViewModel之间做了双向数据绑定。如果MVVM没有Binder，那么它与MVC的差异不是很大。

> **Q：View和ViewModel之间是否一定要解耦？**
>  A：View持有ViewModel，ViewModel不能持有View（即ViewModel不能依赖UIKit中任何东西）。说明白了吧？  解耦是有一定成本的，不管是通过Category或者中间件，消息链条都会无形之中变长，会有一定的DEBUG成本。
>
> **Q：为什么ViewModel不能持有View？**
>  A：这个很好理解啊兄dei，主要有两方面原因：1.ViewModel可测性，即单元测试方便进行。2.团队人员可分离开发（View和ViewModel开发可以是两个人同时进行）。

### 8. 什么是 SPA 单页面，它的优缺点分别是什么

> **SPA**（ single-page application ）即一个web项目就只有一个页面（即一个HTML文件,HTML 内容的变换是利用***路由机制***实现的。

**优点：**

1. **用户体验好、快**，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
2. 基于上面一点，SPA 相对**对服务器压力小**；
3. **前后端职责分离**，架构清晰，前端进行交互逻辑，后端负责数据处理；

**缺点：**

1. **初次加载耗时多**：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
2. 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换**需要自己建立堆栈管理**；
3. **SEO 难度较大**：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。

### 9. vue的生命周期

> vue生命周期？： Vue 实例从创建到销毁的过程，就是生命周期。

*注意*：浏览器有**8个钩子**，但是node中做服务端渲染的时候只有beforeCreate和created

**beforeCreate**（new vue（）之后的第一个钩子）

**created** (实例创建完成后发生，当前阶段 已完成 `数据监测`)

**beforeMount**（发生在挂载之前，当前阶段 `虚拟DOM` 已创建完成 ，`即将开始渲染`）

**mounted**（挂载完成后）真实的Dom`挂载完毕`，数据完成双向绑定，

**beforeupdate**（更新前）也就是响应式数据发生更新，虚拟dom`重新渲染之前`被触发，

**updated**（更新完成后）Dom已完成更新，注意**`避免`**在此期间更改数据，否则可能会导致`无限循环`更新

**beforeDestory**（实例销毁前） 当前实例完全可以被使用，在此时可以进行收尾工作，如清除定时器、销毁父组件对子组件的重复监听等

**destroyed**（实例销毁后）此时只剩下DOM空壳。

##### 每个周期具体适合哪些场景

- `beforecreate` : 可以在这加个loading事件，在加载实例时触发
- `created` : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用
- `mounted` : 挂载元素，获取到DOM节点
- `updated` : 如果对数据统一处理，在这里写上相应函数
- `beforeDestroy` : 可以清除定时器
- `nextTick` : 更新数据后立即操作dom

### 10. 异步请求适合在哪个生命周期调用？

官方实例的异步请求是在`mounted`生命周期中调用的，而实际上也可以在created生命周期中调用。

推荐在 created 钩子函数中调用异步请求，有以下优点：

- 能更快获取到服务端数据，减少页面 loading 时间；
- ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；

### 11. 什么是SSR

SSR也就是`服务端渲染`，也就是将Vue在客户端把`标签渲染成HTML`的工作放在服务端完成，然后再把`html直接返回`给客户端

#### **1）服务端渲染的优点：**

- **更好的 SEO：** 直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；

- **更快的内容到达时间（首屏加载更快）：**SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；

#### **2) 服务端渲染的缺点：**

- **开发条件限制：** 例如服务端渲染只支持 `beforCreate` 和 `created` 两个钩子函数，

- **更多的服务器负载：** 在 Node.js 服务器端中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源

### 12. v-show 与 v-if 的区别

**v-if**           适用于在运行时`很少改变条件`，`不需要频繁切换`条件的场景；
**v-show**    则适用于需要非常频繁切换条件的场景

### 13. H5、CSS3新特性

- #### 新元素：< canva >标签

  标签定义图形，比如图表和其他图像。该标签基于 JavaScript 的绘图 API

- #### 新表单元素：

  ```html
  <datalist> 	 // 输入域的选项列表,与 input 元素配合使用
  <keygen>	 // 用于表单的密钥对生成器字段,提供一种验证用户的可靠方法。
  <output>	 // 用于不同类型的输出，比如计算或脚本输出
  ```

- #### 新的表单 Input 类型

- color
- date
- datetime
- datetime-local
- email
- month
- number
- range
- search
- tel
- time
- url
- week

### 14. GET 还是 POST？

与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。

然而，在以下情况中，请使用 POST 请求：

- 无法使用缓存文件（更新服务器上的文件或数据库）
- 向服务器发送大量数据（POST 没有数据量限制）
- 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠

### 15. 回流和重绘？

**回流（reflow）**，元素的大小或者位置发生改变，页面布局和几何信息改变时，**（页面重新渲染）**

**重绘（repaint ）**，元素样式的改变，**（但宽高、大小、位置等不变）**

⭐注：1、影响DOM布局，才会导致回流！！

​			 2、回流一定会导致重绘！！

### 16. 常见的请求头和响应头

#### 1)请求(客户端->服务端[request]) 

  GET(请求的方式) /newcoder/hello.html(请求的目标资源) HTTP/1.1(请求采用的协议和版本号) 
  Accept: */*(客户端能接收的资源类型) 
  Accept-Language: en-us(客户端接收的语言类型) 
  Connection: Keep-Alive(维护客户端和服务端的连接关系) 
  Host: localhost:8080(连接的目标主机和端口号) 
  Referer: http://localhost/links.asp(告诉服务器我来自于哪里) 
  User-Agent: Mozilla/4.0(客户端版本号的名字) 
  Accept-Encoding: gzip, deflate(客户端能接收的压缩数据的类型) 
  If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT(缓存时间) 
  Cookie(客户端暂存服务端的信息) 

  Date: Tue, 11 Jul 2000 18:23:51 GMT(客户端请求服务端的时间)



#### 2)响应(服务端->客户端[response])

  HTTP/1.1(响应采用的协议和版本号) 200(状态码) OK(描述信息)
  Location: http://www.baidu.com(服务端需要客户端访问的页面路径) 
  Server:apache tomcat(服务端的Web服务端名)
  Content-Encoding: gzip(服务端能够发送压缩编码类型) 
  Content-Length: 80(服务端发送的压缩数据的长度) 
  Content-Language: zh-cn(服务端发送的语言类型) 
  Content-Type: text/html; charset=GB2312(服务端发送的类型及采用的编码方式)
  Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT(服务端对该资源最后修改的时间)
  Refresh: 1;url=http://www.it315.org(服务端要求客户端1秒钟后，刷新，然后访问指定的页面路径)
  Content-Disposition: attachment; filename=aaa.zip(服务端要求客户端以下载文件的方式打开该文件)
  Transfer-Encoding: chunked(分块传递数据到客户端）  
  Set-Cookie:SS=Q0=5Lb_nQ; path=/search(服务端发送到客户端的暂存数据)
  Expires: -1//3种(服务端禁止客户端缓存页面数据)
  Cache-Control: no-***(服务端禁止客户端缓存页面数据)  
  Pragma: no-***(服务端禁止客户端缓存页面数据)  
  Connection: close(1.0)/(1.1)Keep-Alive(维护客户端和服务端的连接关系)  

  Date: Tue, 11 Jul 2000 18:23:51 GMT(服务端响应客户端的时间)

**在服务器响应客户端的时候，带上Access-Control-Allow-Origin头信息，解决跨域的一种方法。**